<!DOCTYPE html>
<html>
	<head>
		<title>Cadenza: Programmer's Reference</title>
		<script src="resources/modernizr-2.0.6.js"></script>
		<link type='text/css' rel='stylesheet' href='resources/style.css'/> 
		<link type='text/css' rel='stylesheet' href='resources/pygments/sublime.css'/>
		
	</head>
	<body>
		<div id='logo'>Cadenza</div>
		<div class='ribbon-holder'>
			<a href='http://www.github.com/whoward/Cadenza' target="_blank"><span>Fork me on GitHub</span></a>
		</div>
		<div id='content'>
   <h1>Programmer's Reference</h1>

   <section>
   <h2>Introduction</h2>
   <p>Cadenza is a template compiler composed of three parts: a lexer, parser
   and renderer.  All three parts were designed to be interchangeable so you 
   could write a replacement for any of these which should integrate with the
   others seamlessly.</p>

   <p>The lexer takes an input file and converts it into a list of useful tokens
   which the parser can use.  The parser will in turn convert these tokens into 
   an Abstract Syntax Tree (AST) which can be used by the renderer.  The renderer
   finally uses a Context and an AST to create the rendered template.</p>

   <div style='text-align: center;'><img src='resources/stack.png'/></div>

   <p>Cadenza includes a standard stack of lexer/parser/renderer classes which
   is what is used in the shorthand rendering method <tt>Cadenza#render</tt>. This
   reference will cover the standard compiler stack and later will cover writing
   custom compiler components in the <a href='#custom'>custom components</a>
   section.</p>
</section>

   <section>
   <h2>Contexts</h2>
   <p>Contexts are managed by the <tt>Cadenza::Context</tt> class contain all 
   the variable information used when rendering the template, including:</p>

   <ul>
      <li>Variables</li>
      <li>Functional Variables</li>
      <li>Filters</li>
      <li>Blocks</li>
      <li>Loaders</li>
   </ul>

   <p>Cadenza includes a constant named <tt>Cadenza::BaseContext</tt> which was 
   intended, as a convention, to be cloned each time you want to render a 
   template.  Of course, for maximum control, you do not have to do this.</p>

   <p>The purpose of this convention is to allow other developers to mix in their 
   own filters, blocks, loaders, etc. to provide more power to your templates.  
   For example a gem which mixes Cadenza and Ruby on Rails would likely define a
   number of Rails specific filters, variables, etc.</p>
</section>
   <section>
   <h2>Contexts: Configuration</h2>

   <p>All configuration for Cadenza is stored on the context object.  As such 
   any configuration work you want to do when integrating Cadenza should be 
   done on the <tt>Cadenza::BaseContext</tt> object (again, simply a suggestion,
   for maximum control you can always construct your own Context object and
   configure it from there).</p>

   <dl class='parameters'>
      <dt>whiny_template_loading (boolean: default = false)</dt>
      <dd>When loading a template using the regular method <tt>#load_template</tt>
      instead of the bang method <tt>#load_template!</tt> Cadenza will still raise
      a <tt>Cadenza::TemplateNotFoundError</tt> when no template could be loaded.</dd>
   </dl>
</section>
   <section>
   <h2>Contexts: Variables</h2>
   <p>Variables are defined on a <tt>Cadenza::Context</tt> through the context's
   variable stack, accessible through the <tt>#stack</tt> method.  Each level of
   the stack is referred to as a <b>scope</b>.  When looking up variables 
   Cadenza inspects the stack from the top to the bottom.</p>

   <p>To retrieve the value of a variable given it's name (named it's <b>identifier</b>)
   you can use the <tt>#lookup</tt> method.  Be sure to include any dots if the 
   identifier uses dot notation to refer to sub-objects:</p>

   <div class="highlight"><pre><span class="c1"># returns the value of the variable named &quot;foo&quot;</span>
<span class="n">context</span><span class="o">.</span><span class="n">lookup</span> <span class="s2">&quot;foo&quot;</span>

<span class="c1"># returns the value of the variable named &quot;foo&quot; for the value of the variable &quot;bar&quot;</span>
<span class="n">context</span><span class="o">.</span><span class="n">lookup</span> <span class="s2">&quot;foo.bar&quot;</span>
</pre>
</div>


   <p>If the variable couldn't be looked up then <tt>#lookup</tt> will return
   <tt>nil</tt>.</p>

   <p>Values can also be assigned to the top of the stack by using the 
   <tt>#assign</tt>, method:</p>

   <div class="highlight"><pre><span class="n">context</span><span class="o">.</span><span class="n">assign</span> <span class="ss">:foo</span><span class="p">,</span> <span class="s2">&quot;some value for foo&quot;</span>
</pre>
</div>


   <p>To add and removes scopes from the variable stack you can call the
   <tt>#push</tt> and <tt>#pop</tt> methods:</p>

   <div class="highlight"><pre><span class="c1"># now &quot;bar&quot; will be returned when you call context.lookup(&quot;foo&quot;)</span>
<span class="n">context</span><span class="o">.</span><span class="n">push</span> <span class="ss">:foo</span> <span class="o">=&gt;</span> <span class="s2">&quot;bar&quot;</span>

<span class="c1"># now &quot;baz&quot; will be returned when you call context.lookup(&quot;foo&quot;)</span>
<span class="n">context</span><span class="o">.</span><span class="n">push</span> <span class="ss">:foo</span> <span class="o">=&gt;</span> <span class="s2">&quot;baz&quot;</span>

<span class="c1"># and again &quot;bar&quot; is returned when &quot;foo&quot; is looked up</span>
<span class="n">context</span><span class="o">.</span><span class="n">pop</span>
</pre>
</div>

</section>
   <section>
   <h2>Contexts: Functional Variables</h2>

   <p>You can define functional variables by calling the context object's
   <tt>#define_functional_variable</tt> method with the name of the variable and
   an object which responds to <tt>#call</tt>, such as a <tt>Proc</tt>, 
   <tt>lambda</tt> or a <tt>block</tt>.</p>

   <div class="highlight"><pre><span class="n">context</span><span class="o">.</span><span class="n">define_functional_variable</span> <span class="ss">:foo</span> <span class="k">do</span> <span class="o">|</span><span class="n">context</span><span class="o">|</span>
   <span class="c1"># do something here and return the result</span>
<span class="k">end</span>
</pre>
</div>


   <p>When evaluating the variable the passed callable object will be called with
   a variable number of arguments.  The first argument will always be the context
   object.  The remaining arguments will be the parameters the variable is being
   evaluated with.</p>

   <p>To evaluate a functional variable call the <tt>#evaluate_functional_variable</tt>
   method on the context object, passing the name of the variable and an array of the
   parameters for it:</p>

   <div class="highlight"><pre><span class="c1"># calls the &quot;foo&quot; variable proc with &quot;abc&quot; and 123 as the arguments</span>
<span class="n">context</span><span class="o">.</span><span class="n">evaluate_functional_variable</span> <span class="ss">:foo</span><span class="p">,</span> <span class="o">[</span><span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="mi">123</span><span class="o">]</span>
</pre>
</div>

</section>
   <section>
   <h2>Contexts: Filters</h2>

   <p>You can define filters by calling the context object's <tt>#define_filter</tt> 
   method with the name of the filter and an object which responds to <tt>#call</tt>, 
   such as a <tt>Proc</tt>, <tt>lambda</tt> or a <tt>block</tt>.</p>

   <div class="highlight"><pre><span class="n">context</span><span class="o">.</span><span class="n">define_filter</span> <span class="ss">:foo</span> <span class="k">do</span> <span class="o">|</span><span class="n">input</span><span class="o">|</span>
   <span class="c1"># do something here and return the result</span>
<span class="k">end</span>
</pre>
</div>


   <p>When evaluating the filter the passed callable object will be called with
   a variable number of arguments.  The first argument will always be the input
   string object.  The remaining arguments will be the parameters the filter is 
   being evaluated with.</p>

   <p>To evaluate a filter call the <tt>#evaluate_filter</tt> method on the context
   object, passing the name of the filter and an array of the parameters for it:</p>

   <div class="highlight"><pre><span class="c1"># calls the &quot;foo&quot; filter proc with &quot;abc&quot; and 123 as the arguments</span>
<span class="n">context</span><span class="o">.</span><span class="n">evaluate_filter</span> <span class="ss">:foo</span><span class="p">,</span> <span class="o">[</span><span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="mi">123</span><span class="o">]</span>
</pre>
</div>

</section>
   <section>
   <h2>Contexts: Blocks</h2>

   <p>You can define blocks by calling the context object's <tt>#define_block</tt> 
   method with the name of the block and an object which responds to <tt>#call</tt>, 
   such as a <tt>Proc</tt>, <tt>lambda</tt> or a <tt>block</tt>.</p>

   <div class="highlight"><pre><span class="n">context</span><span class="o">.</span><span class="n">define_block</span> <span class="ss">:foo</span> <span class="k">do</span> <span class="o">|</span><span class="n">input</span><span class="o">|</span>
   <span class="c1"># do something here and return the result</span>
<span class="k">end</span>
</pre>
</div>


   <p>When evaluating the block the passed callable object will be called with
   a variable number of arguments.  The first argument will always be the context
   object.  The second argument will be an Array of Node objects which are the 
   block's parsed children, it is up to the callable to render these as it sees fit.
   The remaining arguments will be the parameters the block is being evaluated with.</p>

   <p>To evaluate a block call the <tt>#evaluate_block</tt> method on the context
   object, passing the name of the block, an array of nodes (the block's children),
   and an array of the parameters for it:</p>

   <div class="highlight"><pre><span class="c1"># calls the &quot;foo&quot; block proc with &quot;abc&quot; and 123 as the arguments and</span>
<span class="c1"># a text child node with &quot;xyz&quot; as it&#39;s content</span>
<span class="n">context</span><span class="o">.</span><span class="n">evaluate_filter</span> <span class="ss">:foo</span><span class="p">,</span> <span class="o">[</span><span class="no">Cadenza</span><span class="o">::</span><span class="no">TextNode</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">)</span><span class="o">]</span><span class="p">,</span> <span class="o">[</span><span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="mi">123</span><span class="o">]</span>
</pre>
</div>

</section>
   <section>
   <h2>Contexts: Loaders</h2>
   <p>Loaders are used by the context to load new template content when needed.  For
   example when you use the "extends" tag or the "render" tag.  Loaders are stored
   on the context inside an array.  When loading a template the loaders are searched
   from the first element of the array to the last until a match is found.</p>

   <p>To add a loader onto the list you can call the <tt>#add_loader</tt> method.</p>

   <div class="highlight"><pre><span class="n">context</span><span class="o">.</span><span class="n">add_loader</span> <span class="no">Cadenza</span><span class="o">::</span><span class="no">FilesystemLoader</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;path/to/view_directory&quot;</span><span class="p">)</span>
</pre>
</div>


   <p>To load the content of a file using the loaders you can call either the
   <tt>#load_source</tt> or <tt>#load_source!</tt> method on the context with the
   name of the template you want to load.  The bang version of the method will 
   raise an exception if the given template could not be loaded.</p>

   <div class="highlight"><pre><span class="c1"># should return the file&#39;s text (unparsed) or nil if the template couldn&#39;t</span>
<span class="c1"># be found.</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_source</span> <span class="s2">&quot;path/to/template.cadenza&quot;</span>
</pre>
</div>


   <p>To load the parsed content of a file using the loader you can call either the
   <tt>#load_template</tt> or <tt>#load_template!</tt> in the same fashion as the
   <tt>#load_source</tt> methods.  These will return an AST if the template was 
   successfully loaded.</p>

   <div class="highlight"><pre><span class="c1"># should return an AST for the given template if the template was found, or</span>
<span class="c1"># nil otherwise</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_template</span> <span class="s2">&quot;path/to/template.cadenza&quot;</span>
</pre>
</div>


   <p>Cadenza includes the following loaders:</p>

   <dl class='parameters'>
      <dt>Cadenza::FilesystemLoader</dt>
      <dd>Loads templates directly off of the filesystem from a specified 
      directory.</dd>

      <dt>Cadenza::ZipLoader (TODO: not yet written)</dt>
      <dd>Loads templates from within a specified zip file.  To use this the 
      <tt>rubyzip</tt> gem is also required.</dd>
   </dl>
</section>

   <section>
   <h2>Lexing</h2>

   <p>Lexing is the process of converting an input file's text into a stream of
   tokens.  Most users won't have to concern themselves with Lexing since the 
   parser will manage constructing and using the lexer.</p>

   <p>A token is an array which has two elements in it.  The first element is the
   type of the token and the second will be an instance of <tt>Cadenza::Token</tt>,
   which describes the value of a token.</p>

   <p>The lexer has an input stream assigned to it by using the <tt>#source=</tt>
   method.  From here tokens are parsed from the input by continually calling
   <tt>#next_token</tt> on the lexer.  When there are no more tokens to be 
   retrieved from the input a token <tt>[false, false]</tt> will be returned
   instead.</p>
</section>
   <section>
   <h2>Parsing</h2>

   <p>Parsing is the process of converting an input token stream into an Abstract
   Syntax Tree and is managed by the <tt>Cadenza::Parser</tt> classes.  To parse 
   a template call <tt>#parse</tt> on the parser object like this:</p>

   <div class="highlight"><pre><span class="no">Cadenza</span><span class="o">::</span><span class="no">Parser</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">parse</span> <span class="s2">&quot;Hello {{ x }}!!&quot;</span>
</pre>
</div>


   <p>By default constructing the Parser object will have it use a new instance
   of <tt>Cadenza::Lexer</tt> to process the input but by passing the
   <tt>:lexer</tt> option to the constructor you can use any custom lexer 
   instead:</p>

   <div class="highlight"><pre><span class="no">Cadenza</span><span class="o">::</span><span class="no">Parser</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:lexer</span> <span class="o">=&gt;</span> <span class="no">CustomLexer</span><span class="o">.</span><span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span> <span class="s2">&quot;Hello {{ x }}!!&quot;</span>
</pre>
</div>

</section>
   <section>
   <h2>Rendering</h2>
   <p>Rendering is the process of converting an AST to an output template using
   an instance of <tt>Cadenza::Context</tt>.  The renderer included with Cadenza
   is <tt>Cadenza::TextRenderer</tt> which renders the AST to a text document
   (other renderers may, for example, render to a JSON file or other interesting
   targets).</p>

   <p>Renderers must be instantiated with an IO object used for writing output
   to.  This IO object should already be opened and ready for writing.</p>

   <div class="highlight"><pre><span class="no">Cadenza</span><span class="o">::</span><span class="no">TextRenderer</span><span class="o">.</span><span class="n">new</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;/path/to/file&quot;</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">)</span>

<span class="no">Cadenza</span><span class="o">::</span><span class="no">TextRenderer</span><span class="o">.</span><span class="n">new</span> <span class="no">StringIO</span><span class="o">.</span><span class="n">new</span>
</pre>
</div>


   <p>Once constructed the object can render an AST by calling the <tt>#render</tt>
   method with the AST and context.</p>

   <div class="highlight"><pre><span class="c1"># renders the document using a clone of Cadenza&#39;s BaseContext object (the suggested approach)</span>
<span class="n">renderer</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">document</span><span class="p">,</span> <span class="no">Cadenza</span><span class="o">::</span><span class="no">BaseContext</span><span class="o">.</span><span class="n">clone</span><span class="p">)</span>
</pre>
</div>


   <p>To facilitate template inheritance an array of <tt>Cadenza::BlockNode</tt>
   objects can be passed.</p>

   <div class="highlight"><pre><span class="c1"># you likely won&#39;t have to do this yourself, the renderer usually uses this</span>
<span class="c1"># behavior internally to facilitate template inheritance.</span>

<span class="n">context</span> <span class="o">=</span> <span class="no">Cadenza</span><span class="o">::</span><span class="no">BaseContext</span><span class="o">.</span><span class="n">clone</span>
<span class="n">blocks</span> <span class="o">=</span> <span class="o">[</span><span class="no">Cadenza</span><span class="o">::</span><span class="no">BlockNode</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:foo</span><span class="p">),</span> <span class="no">Cadenza</span><span class="o">::</span><span class="no">BlockNode</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:bar</span><span class="p">)</span><span class="o">]</span>

<span class="n">renderer</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">document</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">blocks</span><span class="p">)</span>
</pre>
</div>


   <p><tt>Cadenza::TextRenderer</tt> also features a class level shorthand to
   render a given AST and context to a string which will be returned</p>

   <div class="highlight"><pre><span class="no">Cadenza</span><span class="o">::</span><span class="no">TextRenderer</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">document</span><span class="p">,</span> <span class="no">Cadenza</span><span class="o">::</span><span class="no">BaseContext</span><span class="o">.</span><span class="n">clone</span><span class="p">)</span>
</pre>
</div>

</section>
   
   <section id='custom'>
   <h2>Writing custom compiler components</h2>
   <p style='color:red;font-size:1.2em;'>Heads up: until Cadenza reaches v1.0.0 
   the component API is still flexible any may be subject to change.  However,
   the current version should be mostly stable and any changes should be minor.</p>
</section>

<section>
   <h2>Custom Lexers</h2>
   <p>Lexers transform raw text into tokens useable by the parser.  Each token
   is a two element <tt>Array</tt> object with the first token being a well 
   defined <tt>Symbol</tt> object (see [documentation] for specifics) (TODO: link here).
   The second object is an instance of <tt>Cadenza::Token</tt> which will hold
   the value of the token.</p>

   <p>The separation between lexer and parser was intentional to help give Cadenza
   the ability to parse multiple input languages.  This may not always be possible
   with Lexers alone since the input language might be very different from Cadenza's
   syntax (example: c++)  but may be possible to parse similar languages such as
   Smarty, Django or Liquid (which were inspirations for Cadenza).</p>

   <p>A new lexer must implement two methods to be useable in Cadenza: 
   <tt>#source=(io_object)</tt> and <tt>#next_token</tt></p>

   <div class="highlight"><pre><span class="k">class</span> <span class="nc">CustomLexer</span>

   <span class="k">def</span> <span class="nf">source</span><span class="o">=</span><span class="p">(</span><span class="n">io_object</span><span class="p">)</span>
      <span class="c1"># reset any internal variables and prepare to read from the io object</span>
   <span class="k">end</span>

   <span class="k">def</span> <span class="nf">next_token</span>
      <span class="c1"># return the next token from the input, if there are no more tokens</span>
      <span class="c1"># then return [false, false]</span>
   <span class="k">end</span>

<span class="k">end</span>
</pre>
</div>

</section>

<section>
   <h2>Custom Parsers</h2>
   <p>Parsers use a Lexer to retrieve tokens from the input template and form
   them into an Abstract Syntax Tree (AST) of the Cadenza Node classes.  The 
   root of the AST should always be a <tt>Cadenza::DocumentNode</tt>.</p>

   <p>Cadenza's included parser <tt>Cadenza::Parser</tt> is a look-ahead left to
   right parser (LALR) generated by ruby's Racc compiler.  While this type of 
   parser has a large advantage of speed and other techincal details (such as
   being able to correctly parser Arithmetic and Boolean expressions) it lacks
   some of the flexibility of other types of parsers, such as recursive descent
   parsers which can be more flexible.</p>

   <p>Even though Cadenza is implemented as this type of parser you aren't required
   at all to implement this as your own parser.  A recursive descent parser or 
   something else entirely should work just as well as Cadenza's LALR parser.</p>

   <p>Cadenza requires the parser have the same constructor as <tt>Cadenza::Parser</tt>
   and also requires it define the <tt>#parse</tt> method.</p>

   <div class="highlight"><pre><span class="k">class</span> <span class="nc">CustomParser</span>

   <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">{})</span>
      <span class="c1"># create a new parser object.  The options has may contain :lexer which</span>
      <span class="c1"># you should use to retrieve tokens, or create a new lexer if it is not</span>
      <span class="c1"># present.</span>
   <span class="k">end</span>

   <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
      <span class="c1"># assign the source to your lexer and parse all tokens from it.  Return</span>
      <span class="c1"># an AST from this method.</span>
   <span class="k">end</span>

<span class="k">end</span>
</pre>
</div>

</section>

<section>
   <h2>Custom Renderers</h2>
   <p>Renderers take an AST and a context object and are expected to write the
   output template to it's given output stream.  The renderer must implement the
   same constructor and also implement the <tt>#render</tt> method.</p>

   <p>To make things a bit easier you may want to subclass <tt>Cadenza::BaseRenderer</tt>
   which will take care of some of the setup for you and make the subclass a bit
   cleaner.</p>

   <div class="highlight"><pre><span class="k">class</span> <span class="nc">CustomRenderer</span>
   <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">io_object</span><span class="p">)</span>
      <span class="c1"># assign the IO object given, when rendering the template should write</span>
      <span class="c1"># directly to this IO object.</span>
   <span class="k">end</span>

   <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="n">document_node</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">blocks</span><span class="o">=[]</span><span class="p">)</span>
      <span class="c1"># navigate the AST (document_node) and render the output to the IO object,</span>
      <span class="c1"># the context can be used to look up values for variables, filters, etc.</span>

      <span class="c1"># When doing template inheritance blocks will be passed as the third parameter</span>
      <span class="c1"># which are expected to be rendered in place of blocks matching the same name</span>
   <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>

</section>

<section>
   <h2>Custom Loaders</h2>
   <p>Loaders are very simple, they must implement two methods: <tt>#load_source</tt>
   or <tt>#load_template</tt> which are expected to return a string or an AST
   respectively.  If they cannot load the given template name they should return
   <tt>nil</tt> so Cadenza knows to move onto the next template.</p>

   <p>Keep in mind, just because most examples show template loading passing in
   paths to files you can use whatever string you want to identify your template,
   for example in a database loader you could specify the template name like so:
   <tt>"template_id:135"</tt>.</p>

   <div class="highlight"><pre><span class="k">class</span> <span class="nc">CustomLoader</span>
   <span class="k">def</span> <span class="nf">load_source</span><span class="p">(</span><span class="n">template_name</span><span class="p">)</span>
      <span class="c1"># return the unparsed source of the given template name or nil if this </span>
      <span class="c1"># loader can&#39;t match a file for the name</span>
   <span class="k">end</span>

   <span class="k">def</span> <span class="nf">load_template</span><span class="p">(</span><span class="n">template_name</span><span class="p">)</span>
      <span class="c1"># return the parsed AST for the given template name or nil if this loader</span>
      <span class="c1"># can&#39;t match a file for the name</span>
   <span class="k">end</span>
<span class="k">end</span>
</pre>
</div>

</section>
</div>
		<nav>
  <h3>Topics</h3>
  <ul>
    <li><a href='index.html'>Home</a></li>
    <li><a href='syntax.html'>Syntax</a></li>
    <li><a href='filters.html'>Filter reference</a></li>
    <li><a href='variables.html'>Variables reference</a></li>
    <li><a href='blocks.html'>Blocks reference</a></li>
    <li><a href='reference.html'>Programming Reference</a></li>
    <li><a href='live.html'>Try Cadenza</a></li>
  </ul>
</nav>
	</body>
</html>
